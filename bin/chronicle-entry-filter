#!/usr/bin/perl
#
#  This script is designed to receive a filename and a global filter
# type upon the command line.
#
#  It should, using whatever optional things are specified, return the
# output blog to STDOUT.
#
# Steve
#

use strict;
use warnings;


use Getopt::Long;



#
#  Get the options from the command line.
#
my %CONFIG = parseCommandLineArguments();



#
#  Open the specified file.
#
open my $handle, "<:utf8", $CONFIG{ 'filename' } or
  die "Failed to open file\n";



#
#  Parse the header and body into these values
#
my %headers;
my $body;


#
#  Read the file.
#
my $header = 1;
foreach my $line (<$handle>)
{
    if ($header)
    {

        #
        #  If the header is "foo:bar" then record that
        #
        if ( $line =~ /^([^:]+):(.*)/ )
        {
            my $key = $1;
            my $val = $2;

            $key = lc($key);
            $val =~ s/^\s+|\s+$//g;

            $headers{ $key } = $val if ( length($val) && !$headers{ $key } );
        }

        #
        #  End of the header?
        #
        $header = 0 if ( $line =~ /^$/ );
    }
    else
    {
        $body .= $line;
    }

}
close($handle);


#
#  At this point we have a list of headers from the entry, and a possible
# global format.
#
#  Do we have a per-file format?
#
#
my $format = $CONFIG{ 'format' } || "html";
if ( $headers{ 'format' } )
{
    $format = $headers{ 'format' };
}

#
#  Now convert and print
#
my $html;


if ( $format =~ /^html$/i )
{
    $html = $body;
}
elsif ( $format =~ /^textile$/i )
{
    $html = textile2HTML($body);
}
elsif ( $format =~ /^markdown$/i )
{
    $html = markdown2HTML($body);
}
else
{
    $html = "<p>Unkown format <tt>$format</tt></p>";
    $html .= $body;
}



#
#  Here is where we do the code formatting, if there is any to be done.
#

print $html;

exit 0;




=begin doc

Parse the two command line options we expect to receive.

TODO: Add help/version/manual/etc

=end doc

=cut

sub parseCommandLineArguments
{
    my %options;

    if (
         !GetOptions( "filename=s", \$options{ 'filename' },
                      "format=s",   \$options{ 'format' } ) )
    {
        exit 1;
    }

    return (%options);
}




=begin doc

  Convert from markdown to HTML.

=end doc

=cut

sub markdown2HTML
{
    my ($text) = (@_);

    #
    #  Make sure we have the module installed.  Use eval to
    # avoid making this mandatory.
    #
    my $test = "use Text::Markdown;";

    #
    #  Test loading the module.
    #
    ## no critic (Eval)
    eval($test);
    ## use critic

    if ($@)
    {
        print <<EOF;

  You have chosen to format your input text via Markdown, but the
 Perl module Text::Markdown is not installed.

  Aborting.
EOF
        exit;
    }

    #
    #  Convert.
    #
    $text = Text::Markdown::markdown($text);
    return ($text);
}



=begin doc

  Convert from textile to HTML.

=end doc

=cut

sub textile2HTML
{
    my ($text) = (@_);

    #
    #  Make sure we have the module installed.  Use eval to
    # avoid making this mandatory.
    #
    my $test = "use Text::Textile;";

    #
    #  Test loading the module.
    #
    ## no critic (Eval)
    eval($test);
    ## use critic


    if ($@)
    {
        print <<EOF;

  You have chosen to format your input text via Textile, but the
 Perl module Text::Textile is not installed.

  Aborting.
EOF
        exit;
    }

    #
    #  Convert, via the textile helper.
    #
    my $textile = new Text::Textile;

    if ( defined( $CONFIG{ 'charset' } ) )
    {
        $CONFIG{ 'verbose' } &&
          print "Formatting via textile with charset $CONFIG{'charset'}\n";

        $textile->charset( $CONFIG{ 'charset' } );
    }

    #
    #  Now return HTML
    #
    my $html = $textile->process($text);
    return ($html);
}
