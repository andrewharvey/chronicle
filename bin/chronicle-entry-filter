#!/usr/bin/perl -w

=head1 NAME

chronicle-entry-filter - Convert blog files to HTML, if required.

=cut

=head1 SYNOPSIS

  Options

    --format     The global format of all entries.
    --filename   The name of the single file to process.

=cut

=head1 ABOUT

This script is designed to receive a filename and a global filter
type upon the command line.

It should, using whatever optional things are specified, return the
output blog to STDOUT.

The global format is a hint to the type of input it will process, and
will be one of "html", "markdown", or "textile".  However the file itself
might specify a different format.

Code may be highlighted via the B<Text::VimColor> module, if it is present.

To enable the code highlighting you should format your code sample as
follows:

=for example begin

   <code lang="perl">
   #!/usr/bin/perl -w
   ...
   ..
   </code>

=for example end

Here the important part is the lang="perl" attribute inside the code tag.

=cut

=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

=cut

=head1 LICENSE

Copyright (c) 2009 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut


use strict;
use warnings;


use Getopt::Long;



#
#  Dispatch table of converters
#
my %dispatch = ( "html"     => \&do_html,
                 "markdown" => \&do_markdown,
                 "textile"  => \&do_textile
               );




#
#  Parse the command line options.
#
my %CONFIG = parseCommandLineArguments();


#
#  If we don't have a filename then it is game over.
#
if ( !$CONFIG{ 'filename' } )
{
    print "Mandatory filename missing: Help?!\n";
    exit 1;
}



#
#  Read the input from the file
#
my ( $text, %headers ) = readInputFile( $CONFIG{ 'filename' } );


#
# At this point we need to work out how to format the entry.
#
# We might have (in order of precedence):
#
#  a. A per-entry format
#  b. A global format.
#  c. The default format (html)
#
my $format = $headers{ 'format' } || $CONFIG{ 'format' } || "html";


#
#  Call the appropriate conversion routine.
#
my $routine = $dispatch{ $format };
my $html    = $routine->($text);


#
#  Here is where we do the code formatting, if there is any to be done.
#
if ( $html =~ /<code lang=['"]([^'"]+)['"]>/mi )
{
    my $lang = $1;
    $html = highlightCode( $html, $lang );
}



#
#  Finally output the result such that chronicle can include it
# in the blog.
#
#  Ensure we're UTF-8 clean.
#
binmode STDOUT, ":utf8";
print $html;

#
#  All over :)
#
exit 0;




=begin doc

Parse the two command line options we expect to receive.

TODO: Add help/version/manual/etc

=end doc

=cut

sub parseCommandLineArguments
{
    my %options;

    if (
         !GetOptions( "filename=s", \$options{ 'filename' },
                      "format=s",   \$options{ 'format' } ) )
    {
        exit 1;
    }

    return (%options);
}



=begin doc

Read the specified blog file, and return both the input format
and the body of the file.

Ignore all other header values.
=end doc

=cut

sub readInputFile
{
    my ($filename) = (@_);

    #
    #  Open the specified file.
    #
    open my $handle, "<:utf8", $filename or
      die "Failed to open file\n";


    #
    #  Parse the header and body into these values
    #
    my %headers;
    my $body;


    #
    #  Read the file.
    #
    my $header = 1;
    foreach my $line (<$handle>)
    {
        if ($header)
        {

            #
            #  If the header is "foo:bar" then record that
            #
            if ( $line =~ /^([^:]+):(.*)/ )
            {
                my $key = $1;
                my $val = $2;

                $key = lc($key);
                $val =~ s/^\s+|\s+$//g;

                $headers{ $key } = $val
                  if ( length($val) && !$headers{ $key } );
            }

            #
            #  End of the header?
            #
            $header = 0 if ( $line =~ /^$/ );
        }
        else
        {
            $body .= $line;
        }

    }
    close($handle);

    return ( $body, %headers );
}



=begin doc

 Convert from HTML to HTML.
 (i.e. NOP)

=end doc

=cut

sub do_html
{
    my ($text) = (@_);

    return ($text);
}



=begin doc

  Convert from markdown to HTML.

=end doc

=cut

sub do_markdown
{
    my ($text) = (@_);

    #
    #  Make sure we have the module installed.  Use eval to
    # avoid making this mandatory.
    #
    my $test = "use Text::Markdown;";

    #
    #  Test loading the module.
    #
    ## no critic (Eval)
    eval($test);
    ## use critic

    if ($@)
    {
        print <<EOF;

  You have chosen to format your input text via Markdown, but the
 Perl module Text::Markdown is not installed.

  Aborting.
EOF
        exit 1;
    }

    #
    #  Convert.
    #
    $text = Text::Markdown::markdown($text);
    return ($text);
}



=begin doc

  Convert from textile to HTML.

=end doc

=cut

sub do_textile
{
    my ($text) = (@_);

    #
    #  Make sure we have the module installed.  Use eval to
    # avoid making this mandatory.
    #
    my $test = "use Text::Textile;";

    #
    #  Test loading the module.
    #
    ## no critic (Eval)
    eval($test);
    ## use critic


    if ($@)
    {
        print <<EOF;

  You have chosen to format your input text via Textile, but the
 Perl module Text::Textile is not installed.

  Aborting.
EOF
        exit 1;
    }

    #
    #  Convert, via the textile helper.
    #
    my $textile = new Text::Textile;

    if ( defined( $CONFIG{ 'charset' } ) )
    {
        $CONFIG{ 'verbose' } &&
          print "Formatting via textile with charset $CONFIG{'charset'}\n";

        $textile->charset( $CONFIG{ 'charset' } );
    }

    #
    #  Now return HTML
    #
    my $html = $textile->process($text);
    return ($html);
}



=begin doc

Attempt to highlight the given text with the given language bindings.

Note that this relies upon Text::VimColor...

=end doc

=cut

sub highlightCode
{
    my ( $text, $lang ) = (@_);


    #
    #  Make sure we have the Text::VimColor  module installed.  Use eval to
    # avoid making this mandatory.
    #
    my $test = "use Text::VimColor;";

    #
    #  Test loading the module.
    #
    ## no critic (Eval)
    eval($test);
    ## use critic

    #
    #  If there was an error then we'll ignore the highlighting.
    #
    if ($@)
    {
        return $text;
    }


    if ( $text =~ /^(.*)<code([^>]+)>(.*)<\/code>(.*)$/mis )
    {
        my $pre  = $1;
        my $lll  = $2;
        my $code = $3;
        my $post = $4;

        my $syntax = Text::VimColor->new( string     => $code,
                                          filetype   => $lang,
                                          stylesheet => 1,
                                        );

        $text = $pre . "\n<code>\n" . $syntax->html . "\n</code>\n" . $post;
    }

    return ($text);
}
